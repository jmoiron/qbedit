package snbt

// Code generated by peg -switch -inline -strict -output snbt_parser.go snbt.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleStart
	ruleValue
	ruleCompound
	rulePair
	ruleKey
	ruleList
	ruleListItem
	ruleString
	ruleStringInner
	ruleEscape
	ruleUnicode
	ruleHex
	ruleNumber
	ruleDecimal
	ruleFloatS
	ruleLong
	ruleShort
	ruleInteger
	ruleDigits
	ruleSign
	ruleBoolean
	ruleFalse
	ruleTrue
	ruleLBRACE
	ruleRBRACE
	ruleLBRACKET
	ruleRBRACKET
	ruleCOLON
	ruleCOMMA
	ruleDQUOTE
	ruleSep
	rule_
	ruleWS
	ruleENDL
	ruleWSP
	ruleEOL
	ruleComment
	ruleAction0
	ruleAction1
	rulePegText
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
)

var rul3s = [...]string{
	"Unknown",
	"Start",
	"Value",
	"Compound",
	"Pair",
	"Key",
	"List",
	"ListItem",
	"String",
	"StringInner",
	"Escape",
	"Unicode",
	"Hex",
	"Number",
	"Decimal",
	"FloatS",
	"Long",
	"Short",
	"Integer",
	"Digits",
	"Sign",
	"Boolean",
	"False",
	"True",
	"LBRACE",
	"RBRACE",
	"LBRACKET",
	"RBRACKET",
	"COLON",
	"COMMA",
	"DQUOTE",
	"Sep",
	"_",
	"WS",
	"ENDL",
	"WSP",
	"EOL",
	"Comment",
	"Action0",
	"Action1",
	"PegText",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type SNBT struct {
	Builder

	Buffer string
	buffer []rune
	rules  [52]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *SNBT) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *SNBT) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *SNBT
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *SNBT) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *SNBT) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *SNBT) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *SNBT) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.BeginCompound()
		case ruleAction1:
			p.PairSet()
		case ruleAction2:
			p.SetKey(text)
		case ruleAction3:
			p.BeginList()
		case ruleAction4:
			p.ListAppend()
		case ruleAction5:
			p.PushString(text)
		case ruleAction6:
			p.PushDecimal(text)
		case ruleAction7:
			p.PushFloat(text)
		case ruleAction8:
			p.PushLong(text)
		case ruleAction9:
			p.PushShort(text)
		case ruleAction10:
			p.PushNumber(text)
		case ruleAction11:
			p.PushBool(false)
		case ruleAction12:
			p.PushBool(true)

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*SNBT) error {
	return func(p *SNBT) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*SNBT) error {
	return func(p *SNBT) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *SNBT) Init(options ...func(*SNBT) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Start <- <(_ Value _ !.)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rule_]() {
					goto l0
				}
				if !_rules[ruleValue]() {
					goto l0
				}
				if !_rules[rule_]() {
					goto l0
				}
				{
					position2, tokenIndex2 := position, tokenIndex
					if !matchDot() {
						goto l2
					}
					goto l0
				l2:
					position, tokenIndex = position2, tokenIndex2
				}
				add(ruleStart, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Value <- <(Boolean / ((&('"') String) | (&('[') List) | (&('{') Compound) | (&('+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') Number)))> */
		func() bool {
			position3, tokenIndex3 := position, tokenIndex
			{
				position4 := position
				{
					position5, tokenIndex5 := position, tokenIndex
					{
						position7 := position
						{
							position8, tokenIndex8 := position, tokenIndex
							{
								position10 := position
								{
									position11, tokenIndex11 := position, tokenIndex
									{
										position13, tokenIndex13 := position, tokenIndex
										if buffer[position] != rune('t') {
											goto l14
										}
										position++
										goto l13
									l14:
										position, tokenIndex = position13, tokenIndex13
										if buffer[position] != rune('T') {
											goto l12
										}
										position++
									}
								l13:
									{
										position15, tokenIndex15 := position, tokenIndex
										if buffer[position] != rune('r') {
											goto l16
										}
										position++
										goto l15
									l16:
										position, tokenIndex = position15, tokenIndex15
										if buffer[position] != rune('R') {
											goto l12
										}
										position++
									}
								l15:
									{
										position17, tokenIndex17 := position, tokenIndex
										if buffer[position] != rune('u') {
											goto l18
										}
										position++
										goto l17
									l18:
										position, tokenIndex = position17, tokenIndex17
										if buffer[position] != rune('U') {
											goto l12
										}
										position++
									}
								l17:
									{
										position19, tokenIndex19 := position, tokenIndex
										if buffer[position] != rune('e') {
											goto l20
										}
										position++
										goto l19
									l20:
										position, tokenIndex = position19, tokenIndex19
										if buffer[position] != rune('E') {
											goto l12
										}
										position++
									}
								l19:
									goto l11
								l12:
									position, tokenIndex = position11, tokenIndex11
									if buffer[position] != rune('1') {
										goto l9
									}
									position++
									{
										position21, tokenIndex21 := position, tokenIndex
										if buffer[position] != rune('b') {
											goto l22
										}
										position++
										goto l21
									l22:
										position, tokenIndex = position21, tokenIndex21
										if buffer[position] != rune('B') {
											goto l9
										}
										position++
									}
								l21:
								}
							l11:
								if !_rules[ruleWSP]() {
									goto l9
								}
								{
									add(ruleAction12, position)
								}
								add(ruleTrue, position10)
							}
							goto l8
						l9:
							position, tokenIndex = position8, tokenIndex8
							{
								position24 := position
								{
									position25, tokenIndex25 := position, tokenIndex
									{
										position27, tokenIndex27 := position, tokenIndex
										if buffer[position] != rune('f') {
											goto l28
										}
										position++
										goto l27
									l28:
										position, tokenIndex = position27, tokenIndex27
										if buffer[position] != rune('F') {
											goto l26
										}
										position++
									}
								l27:
									{
										position29, tokenIndex29 := position, tokenIndex
										if buffer[position] != rune('a') {
											goto l30
										}
										position++
										goto l29
									l30:
										position, tokenIndex = position29, tokenIndex29
										if buffer[position] != rune('A') {
											goto l26
										}
										position++
									}
								l29:
									{
										position31, tokenIndex31 := position, tokenIndex
										if buffer[position] != rune('l') {
											goto l32
										}
										position++
										goto l31
									l32:
										position, tokenIndex = position31, tokenIndex31
										if buffer[position] != rune('L') {
											goto l26
										}
										position++
									}
								l31:
									{
										position33, tokenIndex33 := position, tokenIndex
										if buffer[position] != rune('s') {
											goto l34
										}
										position++
										goto l33
									l34:
										position, tokenIndex = position33, tokenIndex33
										if buffer[position] != rune('S') {
											goto l26
										}
										position++
									}
								l33:
									{
										position35, tokenIndex35 := position, tokenIndex
										if buffer[position] != rune('e') {
											goto l36
										}
										position++
										goto l35
									l36:
										position, tokenIndex = position35, tokenIndex35
										if buffer[position] != rune('E') {
											goto l26
										}
										position++
									}
								l35:
									goto l25
								l26:
									position, tokenIndex = position25, tokenIndex25
									if buffer[position] != rune('0') {
										goto l6
									}
									position++
									{
										position37, tokenIndex37 := position, tokenIndex
										if buffer[position] != rune('b') {
											goto l38
										}
										position++
										goto l37
									l38:
										position, tokenIndex = position37, tokenIndex37
										if buffer[position] != rune('B') {
											goto l6
										}
										position++
									}
								l37:
								}
							l25:
								if !_rules[ruleWSP]() {
									goto l6
								}
								{
									add(ruleAction11, position)
								}
								add(ruleFalse, position24)
							}
						}
					l8:
						add(ruleBoolean, position7)
					}
					goto l5
				l6:
					position, tokenIndex = position5, tokenIndex5
					{
						switch buffer[position] {
						case '"':
							{
								position41 := position
								if !_rules[ruleDQUOTE]() {
									goto l3
								}
								{
									position42 := position
									if !_rules[ruleStringInner]() {
										goto l3
									}
									add(rulePegText, position42)
								}
								if !_rules[ruleDQUOTE]() {
									goto l3
								}
								if !_rules[ruleWSP]() {
									goto l3
								}
								{
									add(ruleAction5, position)
								}
								add(ruleString, position41)
							}
						case '[':
							{
								position44 := position
								{
									position45 := position
									if buffer[position] != rune('[') {
										goto l3
									}
									position++
									if !_rules[ruleWSP]() {
										goto l3
									}
									add(ruleLBRACKET, position45)
								}
								{
									add(ruleAction3, position)
								}
								{
									position47, tokenIndex47 := position, tokenIndex
									if !_rules[rule_]() {
										goto l47
									}
									if !_rules[ruleListItem]() {
										goto l47
									}
								l49:
									{
										position50, tokenIndex50 := position, tokenIndex
										if !_rules[ruleSep]() {
											goto l50
										}
										if !_rules[ruleListItem]() {
											goto l50
										}
										goto l49
									l50:
										position, tokenIndex = position50, tokenIndex50
									}
									goto l48
								l47:
									position, tokenIndex = position47, tokenIndex47
								}
							l48:
								if !_rules[rule_]() {
									goto l3
								}
								{
									position51 := position
									if buffer[position] != rune(']') {
										goto l3
									}
									position++
									if !_rules[ruleWSP]() {
										goto l3
									}
									add(ruleRBRACKET, position51)
								}
								add(ruleList, position44)
							}
						case '{':
							{
								position52 := position
								{
									position53 := position
									if buffer[position] != rune('{') {
										goto l3
									}
									position++
									if !_rules[ruleWSP]() {
										goto l3
									}
									add(ruleLBRACE, position53)
								}
								{
									add(ruleAction0, position)
								}
								{
									position55, tokenIndex55 := position, tokenIndex
									if !_rules[rule_]() {
										goto l55
									}
									if !_rules[rulePair]() {
										goto l55
									}
								l57:
									{
										position58, tokenIndex58 := position, tokenIndex
										if !_rules[ruleSep]() {
											goto l58
										}
										if !_rules[rulePair]() {
											goto l58
										}
										goto l57
									l58:
										position, tokenIndex = position58, tokenIndex58
									}
									goto l56
								l55:
									position, tokenIndex = position55, tokenIndex55
								}
							l56:
								if !_rules[rule_]() {
									goto l3
								}
								{
									position59 := position
									if buffer[position] != rune('}') {
										goto l3
									}
									position++
									if !_rules[ruleWSP]() {
										goto l3
									}
									add(ruleRBRACE, position59)
								}
								add(ruleCompound, position52)
							}
						default:
							{
								position60 := position
								{
									position61, tokenIndex61 := position, tokenIndex
									{
										position63 := position
										{
											position64 := position
											{
												position65, tokenIndex65 := position, tokenIndex
												if !_rules[ruleSign]() {
													goto l65
												}
												goto l66
											l65:
												position, tokenIndex = position65, tokenIndex65
											}
										l66:
											if !_rules[ruleDigits]() {
												goto l62
											}
											{
												position67, tokenIndex67 := position, tokenIndex
												if buffer[position] != rune('.') {
													goto l67
												}
												position++
												if !_rules[ruleDigits]() {
													goto l67
												}
												goto l68
											l67:
												position, tokenIndex = position67, tokenIndex67
											}
										l68:
											{
												position69, tokenIndex69 := position, tokenIndex
												if buffer[position] != rune('d') {
													goto l70
												}
												position++
												goto l69
											l70:
												position, tokenIndex = position69, tokenIndex69
												if buffer[position] != rune('D') {
													goto l62
												}
												position++
											}
										l69:
											add(rulePegText, position64)
										}
										if !_rules[ruleWSP]() {
											goto l62
										}
										{
											add(ruleAction6, position)
										}
										add(ruleDecimal, position63)
									}
									goto l61
								l62:
									position, tokenIndex = position61, tokenIndex61
									{
										position73 := position
										{
											position74 := position
											{
												position75, tokenIndex75 := position, tokenIndex
												if !_rules[ruleSign]() {
													goto l75
												}
												goto l76
											l75:
												position, tokenIndex = position75, tokenIndex75
											}
										l76:
											if !_rules[ruleDigits]() {
												goto l72
											}
											{
												position77, tokenIndex77 := position, tokenIndex
												if buffer[position] != rune('.') {
													goto l77
												}
												position++
												if !_rules[ruleDigits]() {
													goto l77
												}
												goto l78
											l77:
												position, tokenIndex = position77, tokenIndex77
											}
										l78:
											{
												position79, tokenIndex79 := position, tokenIndex
												if buffer[position] != rune('f') {
													goto l80
												}
												position++
												goto l79
											l80:
												position, tokenIndex = position79, tokenIndex79
												if buffer[position] != rune('F') {
													goto l72
												}
												position++
											}
										l79:
											add(rulePegText, position74)
										}
										if !_rules[ruleWSP]() {
											goto l72
										}
										{
											add(ruleAction7, position)
										}
										add(ruleFloatS, position73)
									}
									goto l61
								l72:
									position, tokenIndex = position61, tokenIndex61
									{
										position83 := position
										{
											position84 := position
											{
												position85, tokenIndex85 := position, tokenIndex
												if !_rules[ruleSign]() {
													goto l85
												}
												goto l86
											l85:
												position, tokenIndex = position85, tokenIndex85
											}
										l86:
											if !_rules[ruleDigits]() {
												goto l82
											}
											{
												position87, tokenIndex87 := position, tokenIndex
												if buffer[position] != rune('l') {
													goto l88
												}
												position++
												goto l87
											l88:
												position, tokenIndex = position87, tokenIndex87
												if buffer[position] != rune('L') {
													goto l82
												}
												position++
											}
										l87:
											add(rulePegText, position84)
										}
										if !_rules[ruleWSP]() {
											goto l82
										}
										{
											add(ruleAction8, position)
										}
										add(ruleLong, position83)
									}
									goto l61
								l82:
									position, tokenIndex = position61, tokenIndex61
									{
										position91 := position
										{
											position92 := position
											{
												position93, tokenIndex93 := position, tokenIndex
												if !_rules[ruleSign]() {
													goto l93
												}
												goto l94
											l93:
												position, tokenIndex = position93, tokenIndex93
											}
										l94:
											if !_rules[ruleDigits]() {
												goto l90
											}
											{
												position95, tokenIndex95 := position, tokenIndex
												if buffer[position] != rune('s') {
													goto l96
												}
												position++
												goto l95
											l96:
												position, tokenIndex = position95, tokenIndex95
												if buffer[position] != rune('S') {
													goto l90
												}
												position++
											}
										l95:
											add(rulePegText, position92)
										}
										if !_rules[ruleWSP]() {
											goto l90
										}
										{
											add(ruleAction9, position)
										}
										add(ruleShort, position91)
									}
									goto l61
								l90:
									position, tokenIndex = position61, tokenIndex61
									{
										position98 := position
										{
											position99 := position
											{
												position100, tokenIndex100 := position, tokenIndex
												if !_rules[ruleSign]() {
													goto l100
												}
												goto l101
											l100:
												position, tokenIndex = position100, tokenIndex100
											}
										l101:
											if !_rules[ruleDigits]() {
												goto l3
											}
											add(rulePegText, position99)
										}
										if !_rules[ruleWSP]() {
											goto l3
										}
										{
											add(ruleAction10, position)
										}
										add(ruleInteger, position98)
									}
								}
							l61:
								add(ruleNumber, position60)
							}
						}
					}

				}
			l5:
				add(ruleValue, position4)
			}
			return true
		l3:
			position, tokenIndex = position3, tokenIndex3
			return false
		},
		/* 2 Compound <- <(LBRACE Action0 (_ Pair (Sep Pair)*)? _ RBRACE)> */
		nil,
		/* 3 Pair <- <(Key COLON Value Action1)> */
		func() bool {
			position104, tokenIndex104 := position, tokenIndex
			{
				position105 := position
				{
					position106 := position
					{
						position107, tokenIndex107 := position, tokenIndex
						{
							position109 := position
							{
								switch buffer[position] {
								case '_':
									if buffer[position] != rune('_') {
										goto l108
									}
									position++
								case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
									if c := buffer[position]; c < rune('a') || c > rune('z') {
										goto l108
									}
									position++
								default:
									if c := buffer[position]; c < rune('A') || c > rune('Z') {
										goto l108
									}
									position++
								}
							}

						l111:
							{
								position112, tokenIndex112 := position, tokenIndex
								{
									switch buffer[position] {
									case '.':
										if buffer[position] != rune('.') {
											goto l112
										}
										position++
									case '-':
										if buffer[position] != rune('-') {
											goto l112
										}
										position++
									case '_':
										if buffer[position] != rune('_') {
											goto l112
										}
										position++
									case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l112
										}
										position++
									case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
										if c := buffer[position]; c < rune('a') || c > rune('z') {
											goto l112
										}
										position++
									default:
										if c := buffer[position]; c < rune('A') || c > rune('Z') {
											goto l112
										}
										position++
									}
								}

								goto l111
							l112:
								position, tokenIndex = position112, tokenIndex112
							}
							add(rulePegText, position109)
						}
						goto l107
					l108:
						position, tokenIndex = position107, tokenIndex107
						if !_rules[ruleDQUOTE]() {
							goto l104
						}
						{
							position114 := position
							if !_rules[ruleStringInner]() {
								goto l104
							}
							add(rulePegText, position114)
						}
						if !_rules[ruleDQUOTE]() {
							goto l104
						}
					}
				l107:
					if !_rules[ruleWSP]() {
						goto l104
					}
					{
						add(ruleAction2, position)
					}
					add(ruleKey, position106)
				}
				{
					position116 := position
					if buffer[position] != rune(':') {
						goto l104
					}
					position++
					if !_rules[ruleWSP]() {
						goto l104
					}
					add(ruleCOLON, position116)
				}
				if !_rules[ruleValue]() {
					goto l104
				}
				{
					add(ruleAction1, position)
				}
				add(rulePair, position105)
			}
			return true
		l104:
			position, tokenIndex = position104, tokenIndex104
			return false
		},
		/* 4 Key <- <((<(((&('_') '_') | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z])) ((&('.') '.') | (&('-') '-') | (&('_') '_') | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]))*)> / (DQUOTE <StringInner> DQUOTE)) WSP Action2)> */
		nil,
		/* 5 List <- <(LBRACKET Action3 (_ ListItem (Sep ListItem)*)? _ RBRACKET)> */
		nil,
		/* 6 ListItem <- <(Value Action4)> */
		func() bool {
			position120, tokenIndex120 := position, tokenIndex
			{
				position121 := position
				if !_rules[ruleValue]() {
					goto l120
				}
				{
					add(ruleAction4, position)
				}
				add(ruleListItem, position121)
			}
			return true
		l120:
			position, tokenIndex = position120, tokenIndex120
			return false
		},
		/* 7 String <- <(DQUOTE <StringInner> DQUOTE WSP Action5)> */
		nil,
		/* 8 StringInner <- <(Escape / (!'"' .))*> */
		func() bool {
			{
				position125 := position
			l126:
				{
					position127, tokenIndex127 := position, tokenIndex
					{
						position128, tokenIndex128 := position, tokenIndex
						{
							position130 := position
							{
								position131, tokenIndex131 := position, tokenIndex
								if buffer[position] != rune('\\') {
									goto l132
								}
								position++
								{
									switch buffer[position] {
									case 't':
										if buffer[position] != rune('t') {
											goto l132
										}
										position++
									case 'r':
										if buffer[position] != rune('r') {
											goto l132
										}
										position++
									case 'n':
										if buffer[position] != rune('n') {
											goto l132
										}
										position++
									case 'f':
										if buffer[position] != rune('f') {
											goto l132
										}
										position++
									case 'b':
										if buffer[position] != rune('b') {
											goto l132
										}
										position++
									case '/':
										if buffer[position] != rune('/') {
											goto l132
										}
										position++
									case '"':
										if buffer[position] != rune('"') {
											goto l132
										}
										position++
									default:
										if buffer[position] != rune('\\') {
											goto l132
										}
										position++
									}
								}

								goto l131
							l132:
								position, tokenIndex = position131, tokenIndex131
								{
									position134 := position
									if buffer[position] != rune('\\') {
										goto l129
									}
									position++
									if buffer[position] != rune('u') {
										goto l129
									}
									position++
									if !_rules[ruleHex]() {
										goto l129
									}
									if !_rules[ruleHex]() {
										goto l129
									}
									if !_rules[ruleHex]() {
										goto l129
									}
									if !_rules[ruleHex]() {
										goto l129
									}
									add(ruleUnicode, position134)
								}
							}
						l131:
							add(ruleEscape, position130)
						}
						goto l128
					l129:
						position, tokenIndex = position128, tokenIndex128
						{
							position135, tokenIndex135 := position, tokenIndex
							if buffer[position] != rune('"') {
								goto l135
							}
							position++
							goto l127
						l135:
							position, tokenIndex = position135, tokenIndex135
						}
						if !matchDot() {
							goto l127
						}
					}
				l128:
					goto l126
				l127:
					position, tokenIndex = position127, tokenIndex127
				}
				add(ruleStringInner, position125)
			}
			return true
		},
		/* 9 Escape <- <(('\\' ((&('t') 't') | (&('r') 'r') | (&('n') 'n') | (&('f') 'f') | (&('b') 'b') | (&('/') '/') | (&('"') '"') | (&('\\') '\\'))) / Unicode)> */
		nil,
		/* 10 Unicode <- <('\\' 'u' Hex Hex Hex Hex)> */
		nil,
		/* 11 Hex <- <((&('a' | 'b' | 'c' | 'd' | 'e' | 'f') [a-f]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F') [A-F]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]))> */
		func() bool {
			position138, tokenIndex138 := position, tokenIndex
			{
				position139 := position
				{
					switch buffer[position] {
					case 'a', 'b', 'c', 'd', 'e', 'f':
						if c := buffer[position]; c < rune('a') || c > rune('f') {
							goto l138
						}
						position++
					case 'A', 'B', 'C', 'D', 'E', 'F':
						if c := buffer[position]; c < rune('A') || c > rune('F') {
							goto l138
						}
						position++
					default:
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l138
						}
						position++
					}
				}

				add(ruleHex, position139)
			}
			return true
		l138:
			position, tokenIndex = position138, tokenIndex138
			return false
		},
		/* 12 Number <- <(Decimal / FloatS / Long / Short / Integer)> */
		nil,
		/* 13 Decimal <- <(<(Sign? Digits ('.' Digits)? ('d' / 'D'))> WSP Action6)> */
		nil,
		/* 14 FloatS <- <(<(Sign? Digits ('.' Digits)? ('f' / 'F'))> WSP Action7)> */
		nil,
		/* 15 Long <- <(<(Sign? Digits ('l' / 'L'))> WSP Action8)> */
		nil,
		/* 16 Short <- <(<(Sign? Digits ('s' / 'S'))> WSP Action9)> */
		nil,
		/* 17 Integer <- <(<(Sign? Digits)> WSP Action10)> */
		nil,
		/* 18 Digits <- <[0-9]+> */
		func() bool {
			position147, tokenIndex147 := position, tokenIndex
			{
				position148 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l147
				}
				position++
			l149:
				{
					position150, tokenIndex150 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l150
					}
					position++
					goto l149
				l150:
					position, tokenIndex = position150, tokenIndex150
				}
				add(ruleDigits, position148)
			}
			return true
		l147:
			position, tokenIndex = position147, tokenIndex147
			return false
		},
		/* 19 Sign <- <('+' / '-')> */
		func() bool {
			position151, tokenIndex151 := position, tokenIndex
			{
				position152 := position
				{
					position153, tokenIndex153 := position, tokenIndex
					if buffer[position] != rune('+') {
						goto l154
					}
					position++
					goto l153
				l154:
					position, tokenIndex = position153, tokenIndex153
					if buffer[position] != rune('-') {
						goto l151
					}
					position++
				}
			l153:
				add(ruleSign, position152)
			}
			return true
		l151:
			position, tokenIndex = position151, tokenIndex151
			return false
		},
		/* 20 Boolean <- <(True / False)> */
		nil,
		/* 21 False <- <(((('f' / 'F') ('a' / 'A') ('l' / 'L') ('s' / 'S') ('e' / 'E')) / ('0' ('b' / 'B'))) WSP Action11)> */
		nil,
		/* 22 True <- <(((('t' / 'T') ('r' / 'R') ('u' / 'U') ('e' / 'E')) / ('1' ('b' / 'B'))) WSP Action12)> */
		nil,
		/* 23 LBRACE <- <('{' WSP)> */
		nil,
		/* 24 RBRACE <- <('}' WSP)> */
		nil,
		/* 25 LBRACKET <- <('[' WSP)> */
		nil,
		/* 26 RBRACKET <- <(']' WSP)> */
		nil,
		/* 27 COLON <- <(':' WSP)> */
		nil,
		/* 28 COMMA <- <','> */
		nil,
		/* 29 DQUOTE <- <'"'> */
		func() bool {
			position164, tokenIndex164 := position, tokenIndex
			{
				position165 := position
				if buffer[position] != rune('"') {
					goto l164
				}
				position++
				add(ruleDQUOTE, position165)
			}
			return true
		l164:
			position, tokenIndex = position164, tokenIndex164
			return false
		},
		/* 30 Sep <- <((COMMA _) / ENDL)> */
		func() bool {
			position166, tokenIndex166 := position, tokenIndex
			{
				position167 := position
				{
					position168, tokenIndex168 := position, tokenIndex
					{
						position170 := position
						if buffer[position] != rune(',') {
							goto l169
						}
						position++
						add(ruleCOMMA, position170)
					}
					if !_rules[rule_]() {
						goto l169
					}
					goto l168
				l169:
					position, tokenIndex = position168, tokenIndex168
					{
						position171 := position
						if !_rules[ruleWSP]() {
							goto l166
						}
						if !_rules[ruleEOL]() {
							goto l166
						}
						if !_rules[ruleWSP]() {
							goto l166
						}
					l172:
						{
							position173, tokenIndex173 := position, tokenIndex
							if !_rules[ruleWSP]() {
								goto l173
							}
							if !_rules[ruleEOL]() {
								goto l173
							}
							if !_rules[ruleWSP]() {
								goto l173
							}
							goto l172
						l173:
							position, tokenIndex = position173, tokenIndex173
						}
						add(ruleENDL, position171)
					}
				}
			l168:
				add(ruleSep, position167)
			}
			return true
		l166:
			position, tokenIndex = position166, tokenIndex166
			return false
		},
		/* 31 _ <- <((&('#' | '/') Comment) | (&('\n' | '\r') EOL) | (&('\t' | ' ') WS))*> */
		func() bool {
			{
				position175 := position
			l176:
				{
					position177, tokenIndex177 := position, tokenIndex
					{
						switch buffer[position] {
						case '#', '/':
							{
								position179 := position
								{
									position180, tokenIndex180 := position, tokenIndex
									if buffer[position] != rune('#') {
										goto l181
									}
									position++
									goto l180
								l181:
									position, tokenIndex = position180, tokenIndex180
									if buffer[position] != rune('/') {
										goto l177
									}
									position++
									if buffer[position] != rune('/') {
										goto l177
									}
									position++
								}
							l180:
							l182:
								{
									position183, tokenIndex183 := position, tokenIndex
									{
										position184, tokenIndex184 := position, tokenIndex
										if !_rules[ruleEOL]() {
											goto l184
										}
										goto l183
									l184:
										position, tokenIndex = position184, tokenIndex184
									}
									if !matchDot() {
										goto l183
									}
									goto l182
								l183:
									position, tokenIndex = position183, tokenIndex183
								}
								if !_rules[ruleEOL]() {
									goto l177
								}
								add(ruleComment, position179)
							}
						case '\n', '\r':
							if !_rules[ruleEOL]() {
								goto l177
							}
						default:
							if !_rules[ruleWS]() {
								goto l177
							}
						}
					}

					goto l176
				l177:
					position, tokenIndex = position177, tokenIndex177
				}
				add(rule_, position175)
			}
			return true
		},
		/* 32 WS <- <(' ' / '\t')> */
		func() bool {
			position185, tokenIndex185 := position, tokenIndex
			{
				position186 := position
				{
					position187, tokenIndex187 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l188
					}
					position++
					goto l187
				l188:
					position, tokenIndex = position187, tokenIndex187
					if buffer[position] != rune('\t') {
						goto l185
					}
					position++
				}
			l187:
				add(ruleWS, position186)
			}
			return true
		l185:
			position, tokenIndex = position185, tokenIndex185
			return false
		},
		/* 33 ENDL <- <(WSP EOL WSP)+> */
		nil,
		/* 34 WSP <- <WS*> */
		func() bool {
			{
				position191 := position
			l192:
				{
					position193, tokenIndex193 := position, tokenIndex
					if !_rules[ruleWS]() {
						goto l193
					}
					goto l192
				l193:
					position, tokenIndex = position193, tokenIndex193
				}
				add(ruleWSP, position191)
			}
			return true
		},
		/* 35 EOL <- <(('\r' '\n') / '\r' / '\n')> */
		func() bool {
			position194, tokenIndex194 := position, tokenIndex
			{
				position195 := position
				{
					position196, tokenIndex196 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l197
					}
					position++
					if buffer[position] != rune('\n') {
						goto l197
					}
					position++
					goto l196
				l197:
					position, tokenIndex = position196, tokenIndex196
					if buffer[position] != rune('\r') {
						goto l198
					}
					position++
					goto l196
				l198:
					position, tokenIndex = position196, tokenIndex196
					if buffer[position] != rune('\n') {
						goto l194
					}
					position++
				}
			l196:
				add(ruleEOL, position195)
			}
			return true
		l194:
			position, tokenIndex = position194, tokenIndex194
			return false
		},
		/* 36 Comment <- <(('#' / ('/' '/')) (!EOL .)* EOL)> */
		nil,
		/* 38 Action0 <- <{ p.BeginCompound() }> */
		nil,
		/* 39 Action1 <- <{ p.PairSet() }> */
		nil,
		nil,
		/* 41 Action2 <- <{ p.SetKey(text) }> */
		nil,
		/* 42 Action3 <- <{ p.BeginList() }> */
		nil,
		/* 43 Action4 <- <{ p.ListAppend() }> */
		nil,
		/* 44 Action5 <- <{ p.PushString(text) }> */
		nil,
		/* 45 Action6 <- <{ p.PushDecimal(text) }> */
		nil,
		/* 46 Action7 <- <{ p.PushFloat(text) }> */
		nil,
		/* 47 Action8 <- <{ p.PushLong(text) }> */
		nil,
		/* 48 Action9 <- <{ p.PushShort(text) }> */
		nil,
		/* 49 Action10 <- <{ p.PushNumber(text) }> */
		nil,
		/* 50 Action11 <- <{ p.PushBool(false)}> */
		nil,
		/* 51 Action12 <- <{ p.PushBool(true) }> */
		nil,
	}
	p.rules = _rules
	return nil
}

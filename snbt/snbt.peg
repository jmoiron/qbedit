package snbt

type SNBT Peg {
    Builder
}

# Entry point
Start <- _ Value _ !.

# Values
Value <- Compound / List / String / Boolean / Number

# Compound: { Pair* }
Compound <- LBRACE { p.BeginCompound() } (_ Pair (Sep Pair)*)? _ RBRACE
Pair <- Key COLON Value { p.PairSet() }

# Key: identifier or quoted string (capture then SetKey)
# Allow dots in unquoted identifiers (e.g., keys like foo.bar)
Key <- (< [A-Za-z_] [A-Za-z0-9_\-.]* > / DQUOTE <StringInner> DQUOTE) WSP { p.SetKey(text) }

# List: '[' x, y, ... ']'
List <- LBRACKET { p.BeginList() } (_ ListItem (Sep ListItem)*)? _ RBRACKET
ListItem <- Value { p.ListAppend() }

# String: double quoted with escapes
String <- DQUOTE <StringInner> DQUOTE WSP { p.PushString(text) }
StringInner <- (Escape / !'"' .)*
Escape <- '\\' [\\"/bfnrt] / Unicode
Unicode <- '\\' 'u' Hex Hex Hex Hex
Hex <- [0-9A-Fa-f]

# Decimal numbers with 'd' or 'D' suffix preserved
Number  <- Decimal / FloatS / Long / Short / Integer
Decimal <- < Sign? Digits ('.' Digits)? [dD] > WSP { p.PushDecimal(text) }
FloatS  <- < Sign? Digits ('.' Digits)? [fF] > WSP { p.PushFloat(text) }
Long    <- < Sign? Digits [lL] > WSP { p.PushLong(text) }
Short   <- < Sign? Digits [sS] > WSP { p.PushShort(text) }
Integer <- < Sign? Digits > WSP { p.PushNumber(text) }

Digits <- [0-9]+
Sign <- ('+' / '-')

# Boolean literals
Boolean <- True / False
False <- ("false" / "0b") WSP { p.PushBool(false)}
True  <- ("true" / "1b") WSP { p.PushBool(true) }

# Punctuators with trailing space
LBRACE <- '{' WSP
RBRACE <- '}' WSP
LBRACKET <- '[' WSP
RBRACKET <- ']' WSP
COLON <- ':' WSP
COMMA <- ','
DQUOTE <- '"'

# Separators: optional comma, whitespace/newlines
Sep <- COMMA _ / ENDL

# Whitespace and comments
_ <- (WS / EOL / Comment)*
WS <- ' ' / '\t'
ENDL <- (WSP EOL WSP)+
WSP <- WS*
EOL <- '\r' '\n' / '\r' / '\n'
Comment <- ('#' / '//') (!EOL .)* EOL
